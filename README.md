<center>COURSE PROJECT</center>

<p align="center">
    <strong>Universidad Peruana de Ciencias Aplicadas</strong><br>
    <img src="https://upload.wikimedia.org/wikipedia/commons/f/fc/UPC_logo_transparente.png"></img><br>
    <strong>Ingeniería de Software</strong><br>
    <strong>Aplicaciones Móviles - NRC7128</strong><br>
    <strong>Profesor: Jorge Luis Mayta Guillermo</strong><br>
    <br>Final Project Report
</p>

<center>

### Startup: **DartlinWave**
#### Product: **LawConnect**

</center>

#### <center>Team  Members:</center>

<center>

| Member                             | Code       |
|------------------------------------|------------|
| Gonzalo Andre Zavala Quedena       | U202113656 |
| Camila Cristina Loli Ramirez       |            |
| Barbara Antonella Espinoza Delgado |            |
| Omar Berrocal Ramirez              |            |

<br> Abril 2025
</center>  


## Registro de Versiones del Informe  
| Version | Fecha      | Autor                           | Descripción de Modificación                  |
|---------|------------|---------------------------------|----------------------------------------------|
|         |            |                                 |                                              |

## Project Report Collaboration Insights  
Analiza cómo la colaboración y la gestión de tareas influyeron en los resultados del proyecto, destacando fortalezas y áreas de mejora para optimizar futuras estrategias.

## Contenido

[Registro de Versiones del Informe](#registro-de-versiones-del-informe)  
[Project Report Collaboration Insights](#project-report-collaboration-insights)  
[Student Outcome](#student-outcome) 

[Objetivos SMART](#objetivos-smart)

[Capítulo I: Presentación](#capítulo-i-presentación)

[1.1 Startup Profile](#11-startup-profile)  
[1.1.1. Descripción de la Startup](#111-descripción-de-la-startup)  
[1.1.2. Perfiles de integrantes del equipo](#112-perfiles-de-integrantes-del-equipo)  

[1.2. Solution Profile](#12-solution-profile)  
[1.2.1 Antecedentes y problemática](#121-antecedentes-y-problemática)  
[1.2.2 Lean UX Process.](#122-lean-ux-process)  
[1.2.2.1. Lean UX Problem Statements.](#1221-lean-ux-problem-statements)  
[1.2.2.2. Lean UX Assumptions.](#1222-lean-ux-assumptions)  
[1.2.2.3. Lean UX Hypothesis Statements.](#1223-lean-ux-hypothesis-statements)  
[1.2.2.4. Lean UX Canvas.](#1224-lean-ux-canvas)  

[1.3. Segmentos objetivo.](#13-segmentos-objetivo)  

[Capítulo II: Requirements Elicitation & Analysis](#capítulo-ii-requirements-elicitation--analysis)  

[2.1. Competidores](#21-competidores)  
[2.1.1. Análisis competitivo](#211-análisis-competitivo)  
[2.1.2. Estrategias y tácticas frente a competidores](#211-análisis-competitivo)  

[2.2. Entrevistas](#22-entrevistas)  
[2.2.1. Diseño de entrevistas](#221-diseño-de-entrevistas)  
[2.2.2. Registro de entrevistas](#222-registro-de-entrevistas)  
[2.2.3. Análisis de entrevistas](#223-análisis-de-entrevistas)  

[2.3. Needfinding](#23-needfinding)  
[2.3.1. User Personas](#231-user-personas)  
[2.3.2. User Task Matrix](#232-user-task-matrix)  
[2.3.3. User Journey Mapping](#233-user-journey-mapping)  
[2.3.4. Empathy Mapping](#234-empathy-mapping)  
[2.3.5. As-is Scenario Mapping](#235-as-is-scenario-mapping) 

[2.4. Ubiquitous Language](#24-ubiquitous-language)  

[Capítulo III: Requirements Specificatio](#capítulo-iii-requirements-specification)  

[3.1. To-Be Scenario Mapping](#31-to-be-scenario-mapping)    
[3.2. User Stories](#32-user-stories)  
[3.3. Impact Mapping](#33-impact-mapping)  
[3.4. Product Backlog](#34-product-backlog)  

[Capítulo IV: Solution Software Design](#capitulo-iv-solution-software-design)

[4.1. Strategic-Level Domain-Driven Design](#41-strategic-level-domain-driven-design)

[4.1.1. EventStorming](#411-eventstorming)  
[4.1.1.1. Candidate Context Discovery](#4111-candidate-context-discovery)  
[4.1.1.2. Domain Message Flows Modeling](#4112-domain-message-flows-modeling)  
[4.1.1.3. Bounded Context Canvases](#4113-bounded-context-canvases)

[4.1.2. Context Mapping](#412-context-mapping)

[4.1.3. Software Architecture](#413-software-architecture)  
[4.1.3.1. Software Architecture Context Level Diagrams](#4131-software-architecture-context-level-diagrams)  
[4.1.3.2. Software Architecture Container Level Diagrams](#4132-software-architecture-container-level-diagrams)  
[4.1.3.3. Software Architecture Deployment Diagrams](#4133-software-architecture-deployment-diagrams)

[4.2. Tactical-Level Domain-Driven Design](#42-tactical-level-domain-driven-design)  
[4.2.5. Bounded Context: Tracking](#425-bounded-context-tracking)  
[4.2.5.1. Domain Layer](#4251-domain-layer)  
[4.2.5.2. Interface Layer](#4252-interface-layer)  
[4.2.5.3. Application Layer](#4253-application-layer)  
[4.2.5.4. Infrastructure Layer](#4254-infrastructure-layer)  
[4.2.5.5. Bounded Context Software Architecture Component Level Diagrams](#4255-bounded-context-software-architecture-component-level-diagrams)  
[4.2.5.6. Bounded Context Software Architecture Code Level Diagrams](#4256-bounded-context-software-architecture-code-level-diagrams)  
[4.2.5.6.1. Bounded Context Domain Layer Class Diagrams](#42561-bounded-context-domain-layer-class-diagrams)  
[4.2.5.6.2. Bounded Context Database Design Diagram](#42562-bounded-context-database-design-diagram)

[Capítulo V: Solution UI/UX Design](#capitulo-v-solution-ui-ux-design)  

[5.1. Product design](#51-product-design)
[5.1.1. Style Guidelines](#511-style-guidelines)  
[5.1.1.1. General Style Guidelines](#5111-general-style-guidelines)

[5.1.2. Information Architecture](#512-information-architecture)  
[5.1.2.1. Organization Systems](#5121-organization-systems)  
[5.1.2.2. Labelling Systems](#5122-labelling-systems)  
[5.1.2.3. SEO Tags and Meta Tags](#5123-seo-tags-and-meta-tags)  
[5.1.2.4. Searching Systems](#5124-searching-systems)  
[5.1.2.5. Navigation Systems](#5125-navigation-systems)

[5.1.3. Landing Page UI Design](#513-landing-page-ui-design)  
[5.1.3.1. Landing Page Wireframe](#5131-landing-page-wireframe)  
[5.1.3.2. Landing Page Mock-up](#5132-landing-page-mock-up)

[5.1.4. Mobile Applications UX/UI Design](#514-mobile-applications-uxui-design)  
[5.1.4.1. Mobile Applications Wireframes](#5141-mobile-applications-wireframes)  
[5.1.4.2. Mobile Applications Wireflow Diagrams](#5142-mobile-applications-wireflow-diagrams)  
[5.1.4.3. Mobile Applications Mock-ups](#5143-mobile-applications-mock-ups)  
[5.1.4.4. Mobile Applications User Flow Diagrams](#5144-mobile-applications-user-flow-diagrams)  
[5.1.4.5. Mobile Applications Prototyping](#5145-mobile-applications-prototyping)

[Capítulo VI: Product Implementation, Validation & Deployment](#capitulo-vi-product-implementation-validation-and-deployment)

[6.1. Software Configuration Management](#61-software-configuration-management)

[6.1.1. Software Development Environment Configuration](#611-software-development-environment-configuration)  
[6.1.2. Source Code Management](#612-source-code-management)  
[6.1.3. Source Code Style Guide & Conventions](#613-source-code-style-guide-conventions)  
[6.1.4. Software Deployment Configuration](#614-software-deployment-configuration)  

[6.2. Landing Page & Mobile Application Implementation](#62-landing-page-and-mobile-application-implementation)

[6.2.X. Sprint n](#62x-sprint-n)
[6.2.X.1. Sprint Planning n](#62x1-sprint-planning-n)
[6.2.X.2. Sprint Backlog n](#62x2-sprint-backlog-n)
[6.2.X.3. Development Evidence for Sprint Review](#62x3-development-evidence-for-sprint-review)
[6.2.X.4. Testing Suite Evidence for Sprint Review](#62x4-testing-suite-evidence-for-sprint-review)
[6.2.X.5. Execution Evidence for Sprint Review](#62x5-execution-evidence-for-sprint-review)
[6.2.X.6. Services Documentation Evidence for Sprint Review](#62x6-services-documentation-evidence-for-sprint-review)
[6.2.X.7. Software Deployment Evidence for Sprint Review](#62x7-software-deployment-evidence-for-sprint-review)
[6.2.X.8. Team Collaboration Insights during Sprint](#62x8-team-collaboration-insights-during-sprint)

[6.3. Validation Interviews](#63-validation-interviews)

[6.3.1. Diseño de Entrevistas](#631-diseño-de-entrevistas)
[6.3.2. Registro de Entrevistas](#632-registro-de-entrevistas)
[6.3.3. Evaluaciones según heurísticas](#633-evaluaciones-segun-heuristicas)

[6.4. Video About-the-Product](#64-video-about-the-product)

[Conclusiones](#conclusiones)  
[Conclusiones y recomendaciones](#conclusiones-y-recomendaciones)  
[Video About-the-Team](#video-about-the-team)  
[Bibliografía](#bibliografía)  
[Anexos](#anexos) 


## Student Outcome

## Objetivos SMART

## Capítulo I: Presentación

### 1.1 Startup Profile

#### 1.1.1. Descripción de la Startup

#### 1.1.2. Perfiles de integrantes del equipo

### 1.2. Solution Profile

#### 1.2.1 Antecedentes y problemática  

#### 1.2.2 Lean UX Process

##### 1.2.2.1. Lean UX Problem Statements

##### 1.2.2.2. Lean UX Assumptions

##### 1.2.2.3. Lean UX Hypothesis Statements

##### 1.2.2.4. Lean UX Canvas

### 1.3. Segmentos objetivo

## Capítulo II: Requirements Elicitation & Analysis

### 2.1. Competidores

#### 2.1.1. Análisis competitivo 

#### 2.1.2. Estrategias y tácticas frente a competidores  

### 2.2. Entrevistas 

#### 2.2.1. Diseño de entrevistas

#### 2.2.2. Registro de entrevistas  

#### 2.2.3. Análisis de entrevistas 

### 2.3. Needfinding 

#### 2.3.1. User Personas  

#### 2.3.2. User Task Matrix

#### 2.3.3. User Journey Mapping

#### 2.3.4. Empathy Mapping 

#### 2.3.5. As-is Scenario Mapping

### 2.4. Ubiquitous Language 

## Capítulo III: Requirements Specificatio

### 3.1. To-Be Scenario Mapping    

### 3.2. User Stories 

### 3.3. Impact Mapping 

### 3.4. Product Backlog 

## Capítulo IV: Solution Software Design

### 4.1. Strategic-Level Domain-Driven Design
<p align="justify">
El diseño estratégico en Domain-Driven Design se enfoca en definir los límites y relaciones entre distintos subdominios del sistema. Esta etapa permitió identificar Bounded Contexts, establecer una visión clara del dominio y organizar los equipos y responsabilidades de forma alineada con el negocio.
</p>

#### 4.1.1. EventStorming  
<p align="justify">
EventStorming es una técnica visual y colaborativa que permite descubrir y entender procesos del dominio a través de eventos clave. Fue utilizada para alinear al equipo y definir los flujos principales del sistema desde una perspectiva de negocio.
</p>

<img src="/assets/images/chapter-iv/event-storming.jpg" alt="Event Storming" width="750"/>

##### 4.1.1.1. Candidate Context Discovery
<p align="justify">
Para esta sesión, el equipo utilizó la herramienta Miro y tuvo una duración de aproximadamente una hora y media. A partir del EventStorming inicial, se aplicó la técnica Start with Value, enfocándonos en las partes del dominio que representan mayor valor para el negocio. Esto permitió identificar las áreas funcionales críticas para el funcionamiento de la aplicación.
</p>

**Técnica aplicada: Start with Value**
<p align="justify">
Dado que el propósito de la aplicación es conectar abogados recién egresados con usuarios que buscan asistencia legal rápida, se priorizaron las siguientes áreas:
</p>

* **Gestión de Casos Legales:** Núcleo de valor, ya que representa el servicio principal del sistema.

* **Asignación de Abogados:** Proceso clave que permite emparejar de forma eficiente a los profesionales con los clientes.

* **Gestión de Usuarios y Autenticación:** Soporte esencial para la interacción en la plataforma.

* **Calificaciones y Reseñas:** Relevante para la confianza y transparencia del servicio.

<p align="justify">
A partir del análisis de los eventos identificados en el EventStorming, y guiándonos por los eventos que generaban transiciones de responsabilidad o cambios significativos de estado (como "Caso creado", "Abogado asignado", "Caso cerrado", "Usuario registrado"), se establecieron límites naturales entre contextos funcionales.
</p>

**Candidate Bounded Contexts Identificados**
**1. Cases:** Gestión de casos legales publicados por clientes y postulaciones de abogados.
**2. Matchmaking:** Lógica para sugerencias inteligentes, filtros por calificación, especialidad, etc.
**3. Tracking:** Seguimiento de la evolución del caso aceptado (progreso, actualizaciones, cierre).

<p align="justify">
La sesión permitió al equipo tener una visión clara de los componentes clave del sistema y sentar las bases para la definición de los Bounded Contexts. Esta claridad será fundamental para aplicar patrones de comunicación entre contextos y mantener la cohesión interna de cada uno.
</p>


##### 4.1.1.2. Domain Message Flows Modeling
<p align="justify">
Una vez identificados los Bounded Contexts, el equipo procedió a modelar cómo estos deben colaborar entre sí para resolver los escenarios clave del negocio. Para ello se utilizó la técnica de Domain Storytelling, que permitió representar de forma clara y narrativa el flujo de mensajes y responsabilidades entre los distintos contextos del dominio.
</p>

**Técnica aplicada: Domain Storytelling**
<p align="justify">
El enfoque se basó en describir casos reales de uso desde la perspectiva de los actores del sistema (clientes, abogados y la plataforma) a través de pasos secuenciales que reflejan las interacciones entre los Bounded Contexts. Esto permitió visualizar cómo fluye la información y qué mensajes deben intercambiarse para cumplir con los objetivos funcionales del sistema.
</p>

**Diagramas y visualización**
<p align="justify"> 
Cada uno de estos escenarios fue representado en <b>Miro</b> como un diagrama de Domain Storytelling, utilizando íconos, actores y flechas que describen la interacción paso a paso. Esta visualización ayudó al equipo a identificar claramente qué Bounded Contexts se comunican, qué datos deben compartirse y en qué orden ocurren las acciones.
</p>

<img src="/assets/images/chapter-iv/storytelling.png" alt="Domain Storytelling" width="700"/>

##### 4.1.1.3. Bounded Context Canvases
<p align="justify">
En esta sección se presentan los Canvases de los bounded contexts identificados durante las actividades previas. Cada Canvas detalla su propósito, reglas de negocio, lenguaje ubicuo, capacidades, dependencias, y una revisión crítica de su diseño, siguiendo un proceso iterativo para refinar su definición.
</p>

**Bounded Context Cases**
<p align="justify">
Encargado de la gestión de los casos legales creados por los clientes. Abarca el proceso de publicación, visualización por parte de los abogados, postulación, selección y aceptación de abogados para un caso.
</p>

<img src="/assets/images/chapter-iv/canvas-cases.png" alt="Canvas Bounded Context Cases" width="800"/>

**Bounded Context Matchmaking**
<p align="justify">
Encargado de sugerir abogados relevantes a los clientes, usando filtros, puntuaciones y lógica de recomendación. Optimiza el proceso de búsqueda y selección.
</p>

<img src="/assets/images/chapter-iv/canvas-matchmaking.png" alt="Canvas Bounded Context Matchmaking" width="800"/>

**Bounded Context Tracking**
<p align="justify">
Supervisa el avance de los casos ya asignados. Incluye hitos, comentarios, y actualizaciones de progreso hasta su cierre.
</p>

<img src="/assets/images/chapter-iv/canvas-tracking.png" alt="Canvas Bounded Context Tracking" width="800"/>


#### 4.1.2. Context Mapping
<p align="justify">
En esta sección veremos ell proceso se llevó a cabo en <b>Miro</b> mediante sesiones de análisis colaborativo que incluyeron preguntas clave que nos ayudaron a evaluar posibles reorganizaciones de capacidades.
</p>

<img src="/assets/images/chapter-iv/context-mapping.png" alt="Context Mapping" width="650"/>

#### 4.1.3. Software Architecture 
<p align="justify">
Esta sección describe la arquitectura del sistema utilizando el modelo C4, alineado con Domain-Driven Design. Se incluyen los niveles de contexto, contenedores y despliegue para mostrar cómo se estructura y ejecuta la solución.
</p>

##### 4.1.3.1. Software Architecture Context Level Diagrams 
<p align="justify">
Este apartado muestra el diagrama de contexto, donde se representa cómo el sistema interactúa con los actores y sistemas externos. Define los límites del sistema y su relación con el entorno.
</p>

<img src="/assets/images/chapter-iv/context-level-diagram.png" alt="Context Level Diagram" width="700"/>

##### 4.1.3.2. Software Architecture Container Level Diagrams
<p align="justify">
Aquí se presenta el diagrama de contenedores, detallando los componentes principales del sistema, su organización interna y cómo colaboran para cumplir los objetivos funcionales.
</p>

<img src="/assets/images/chapter-iv/container-level-diagram.png" alt="Container Level Diagram" width="700"/>

##### 4.1.3.3. Software Architecture Deployment Diagrams

### 4.2. Tactical-Level Domain-Driven Design  
<p align="justify">
En esta sección se explicará el nivel táctico del diseño de nuestro proyecto. A continuación se explicará el diseño para cada bounded context presente en nuestra aplicación.
</p>

#### 4.2.1. Bounded Context: Iam

##### 4.2.1.1. Domain Layer  

La capa de Dominio es la capa que contiene el núcleo del modelo de negocio y la lógica de dominio.

**Aggregate Root:**

* **User:** Entidad raíz que representa los datos de autenticación de un usuario (Abogado/Cliente). Contiene username & contraseña. Tiene lógica interna para su construcción correspondiente.

**Interfaces:**

* **UserCommandService:** Define las operaciones del dominio para aplicar comandos: handle(CreateUserCommand).  
* **UserQueryService:** Define las operaciones del dominio para ejecutar consultas: handle(GetUserByIdQuery) y handle(GetUserByUsernameQuery).

**Comandos:**

* **SignUpCommand:** Objeto inmutable que encapsula los datos necesarios para crear una nueva instancia de User.
* **SignInCommand:** Objeto inmutable que encapsula los datos necesarios para validar el inicio de sesión del usuario.

**Consultas:**

* **GetUserByIdQuery:** Objeto inmutable para solicitar usuario por ID.  
* **GetUserByUsernameQuery:** Objeto inmutable para solicitar usuario por el Username.

##### 4.2.1.2. Interface Layer  

La capa de Interfaz es la capa responsable de exponer el API al exterior y transformar los datos entre el modelo de dominio y los recursos HTTP.

**UsersController:**  
<p align="justify">
Controlador que representa los metodos que se van a exponer a la web, esta clase se encarga de interactuar con el usuario mediante HTTP. Esta clase tiene dependencias con los transformadores y los contratos definidos para cada servicio, esto porque los transformadores tienen la responsabilidad de serializar las clases que representan respuestas del servicio en commandos o en la entidad principal.  
</p>

**Recursos:**

* **SignUpResource:** Objeto inmutable que representa los datos enviados por el cliente para registrarse.
* **SignInResource:** Objeto inmutable que representa los datos enviados por el cliente para iniciar sesión.
* **UserResource:** Objeto inmutable que representa los datos de usuario enviados por el cliente para obtener sus datos.

**Assemblers (Transformadores):**

* **SignInCommandFromResourceAssembler:** Convierte SignInResource en SignInCommand.
* **SignUpCommandFromResourceAssembler:** Convierte SignUpResource en SignUpCommand.
* **UserResourceFromEntityAssembler:** Transforma un objeto del dominio User en un UserResource para ser enviado al cliente.

##### 4.2.1.3. Application Layer  

<p align="justify">
La capa de Aplicación es la capa que contiene la lógica de aplicación, orquesta las operaciones entre capas externas y el dominio.
</p>

**Interfaces:**

* **ExternalProfileService:** Define método para crear un perfil de usuario.

**Implementaciones:**

* **UserCommandServiceImpl:** Implementa la lógica para registrar un usuario o iniciar sesión.

##### 4.2.1.4. Infrastructure Layer  
La capa de Infraestructura es la capa encargada de la persistencia y conexión con sistemas externos.

**Repositorio:**

* **UserRepository:** Interfaz que define operaciones de acceso a datos sobre la entidad User. Su implementación concreta se encargará de interactuar con la base de datos.

##### 4.2.1.5. Bounded Context Software Architecture Component Level Diagrams
<p align="justify">
A continuación se muestra el diagrama de componentes realizado para el Bounded Context <b>"Iam"</b>, mostrando los componentes que lo conformarn.
</p>

<img src="/assets/images/chapter-iv/iam-component-level-diagram.png" alt="IAM Component Level Diagram"/>

##### 4.2.1.6. Bounded Context Software Architecture Code Level Diagrams
<p align="justify">
Esta sección presenta una vista detallada a nivel de código de la arquitectura interna del bounded context "Iam". El objetivo es mostrar cómo se estructuran los elementos fundamentales dentro de cada contexto, desde las clases del dominio hasta el diseño de la base de datos, siguiendo los principios de Domain-Driven Design (DDD).
</p>

###### 4.2.1.6.1. Bounded Context Domain Layer Class Diagrams  
A continuación se muestra el diagrama de clases realizado para el Bounded Context "Iam".

<img src="/assets/images/chapter-iv/iam-class-diagram.png" alt="IAM Class Diagram" width="850"/>

###### 4.2.1.6.2. Bounded Context Database Design Diagram
A continuación se muestra el diagrama de Base de Datos realizado para el Bounded Context "Iam".

<center>
<img src="/assets/images/chapter-iv/iam-database-diagram.png" alt="IAM Database Diagram" width="150"/>
</center>

#### 4.2.2. Bounded Context: Profiles

##### 4.2.2.1. Domain Layer
La capa de Dominio es la capa que contiene el núcleo del modelo de negocio y la lógica de dominio.

**Aggregate Root:**

* **Profile:** Entidad raíz que representa los datos de un usuario (Abogado/Cliente). Contiene datos personales. Tiene lógica interna para su construcción correspondiente.

**Interfaces:**

* **ProfileCommandService:** Define las operaciones del dominio para aplicar comandos: handle(CreateProfileCommand).  
* **ProfileQueryService:** Define las operaciones del dominio para ejecutar consultas: handle(GetProfileByIdQuery) y handle(GetProfileByUserIdQuery).

**Comandos:**

* **CreateProfileCommand:** Objeto inmutable que encapsula los datos necesarios para crear una nueva instancia de Profile.

**Consultas:**

* **GetProfileByIdQuery:** Objeto inmutable para solicitar un perfil por ID.  
* **GetProfileByUserIdQuery:** Objeto inmutable para solicitar perfil por el userId.

##### 4.2.2.2. Interface Layer
La capa de Interfaz es la capa responsable de exponer el API al exterior y transformar los datos entre el modelo de dominio y los recursos HTTP.

**ProfilesController:**  
<p align="justify">
Controlador que representa los metodos que se van a exponer a la web, esta clase se encarga de interactuar con el usuario mediante HTTP. Esta clase tiene dependencias con los transformadores y los contratos definidos para cada servicio, esto porque los transformadores tienen la responsabilidad de serializar las clases que representan respuestas del servicio en commandos o en la entidad principal.  
</p>

**Recursos:**

* **ProfileResource:** Objeto inmutable que representa los datos enviados por el cliente para un perfil de usuario.

**Assemblers (Transformadores):**

* **ProfileFromEntityAssembler:** Transforma un objeto del dominio User en un ProfileResource para ser enviado al cliente.

##### 4.2.2.3. Application Layer
<p align="justify">
La capa de Aplicación es la capa que contiene la lógica de aplicación, orquesta las operaciones entre capas externas y el dominio.
</p>

**Interfaces:**

* **ExternalUserService:** Define método para validar el perfil de un usuario.

**Implementaciones:**

* **UserCommandServiceImpl:** Implementa la lógica para registrar un usuario o iniciar sesión.

##### 4.2.2.4. Infrastructure Layer
La capa de Infraestructura es la capa encargada de la persistencia y conexión con sistemas externos.

**Repositorio:**

* **ProfileRepository:** Interfaz que define operaciones de acceso a datos sobre la entidad User. Su implementación concreta se encargará de interactuar con la base de datos.

##### 4.2.2.5. Bounded Context Software Architecture Component Level Diagrams
<p align="justify">
A continuación se muestra el diagrama de componentes realizado para el Bounded Context <b>"Profiles"</b>, mostrando los componentes que lo conformarn.
</p>

<img src="/assets/images/chapter-iv/profiles-component-level-diagram.png" alt="Profiles Component Level Diagram" width="900"/>

##### 4.2.2.6. Bounded Context Software Architecture Code Level Diagrams
<p align="justify">
Esta sección presenta una vista detallada a nivel de código de la arquitectura interna del bounded context "Profiles". El objetivo es mostrar cómo se estructuran los elementos fundamentales dentro de cada contexto, desde las clases del dominio hasta el diseño de la base de datos, siguiendo los principios de Domain-Driven Design (DDD).
</p>

###### 4.2.2.6.1. Bounded Context Domain Layer Class Diagrams
A continuación se muestra el diagrama de clases realizado para el Bounded Context "Profiles".

<img src="/assets/images/chapter-iv/profiles-class-diagram.png" alt="Profile Class Diagram" width="850"/>


###### 4.2.2.6.2. Bounded Context Database Design Diagram
A continuación se muestra el diagrama de Base de Datos realizado para el Bounded Context "Profiles".

<center>
<img src="/assets/images/chapter-iv/profiles-database-diagram.png" alt="Profiles Database Diagram" width="400"/>
</center>

#### 4.2.3. Bounded Context: Cases

##### 4.2.3.1. Domain Layer  

### Entities

**Legal Case:** Representa un caso legal publicado por un cliente
- **Atributos:**
    - ```Id: UUID```
    - ```ClientId: UUID```
    - ```Title: string```
    - ```Description: string```
    - ```Category: LegalCategory```
    - ```Status: CaseStatus```
    - ```BudgetRange: BudgetRange```
    - ```RequiredDocuments: List<DocumentRequirement>```
    - ```CreatedAt: DateTim```
    - ```UpdatedAt: DateTime```
- **Métodos:**
    - ```Publish():``` Transiciona el caso a estado "publicado"
    - ```AddDocumentRequirement():``` Añade un documento requerido
    - ```Close():``` Cierra el caso

**CaseApplication:** Representa la postulación de un abogado a un caso
- **Atributos:**
    - ```Id: UUID```
    - ```CaseId: UUID```
    - ```LawyerId: UUID```
    - ```ProposalText: string```
    - ```ProposedFee: decimal```
    - ```Status: ApplicationStatus```
    - ```CreatedAt: DateTime```
    - ```UpdatedAt: DateTime```
- **Métodos:**
    - ```Accept():``` Acepta la postulación
    - ```Reject():``` Rechaza la postulación

### Value Objects

**BudgetRange**
- **Atributos:**
    - ```MinAmount: decimal```
    - ```MaxAmount: decimal```
    - ```Currency: string```
- **Métodos:**
    - ```IsWithinRange():``` Verifica si un monto está dentro del rango

**DocumentRequirement**
- **Atributos:**
    - ```Description: string```
    - ```IsMandatory: bool```

### Aggregates

**LegalCaseAggregate**

- **Raíz agregada:** LegalCase
- **Contiene:** CaseApplications asociadas
- **Reglas de invariante:**
    - Solo permite una postulación aceptada por caso
    - No permite modificaciones después de publicación

### Domain Services

**CasePublishingService**
- **Métodos:**
    - ```ValidateAndPublish():``` Valida y publica un caso

**CaseAssignmentService**
- **Métodos:**
    - ```AssignLawyer():``` Asigna abogado a caso

### Repository Interfaces

**ILegalCaseRepository**

Define las operaciones para la gestión de casos legales desde la capa de infraestructura.

- **Métodos:**
    - ```GetById(id: UUID): LegalCase``` – Obtiene un caso legal por su identificador único.
    - ```Add(legalCase: LegalCase)``` – Agrega un nuevo caso legal al sistema.
    - ```Update(legalCase: LegalCase)``` – Actualiza la información de un caso legal existente.

**ICaseApplicationRepository**

Gestiona las postulaciones de abogados a los casos legales.

- **Métodos:**
    - ```GetByCaseId(caseId: UUID): List<CaseApplication>``` – Retorna todas las postulaciones asociadas a un caso.
    - ```Add(application: CaseApplication)``` – Agrega una nueva postulación.
    - ```Update(application: CaseApplication)``` – Actualiza una postulación existente.

##### 4.2.3.2. Interface Layer  

### Controllers
**CasesController**

Controlador que expone los endpoints relacionados con los casos legales.

- **Rutas y métodos:**
    - ```POST /api/cases``` – Crea un nuevo caso legal a partir de un DTO recibido.
    - ```PUT /api/cases/{id}/publish``` – Publica un caso legal con el identificador proporcionado.
- **Dependencias:**
    - ```ICommandHandler<PublishCaseCommand>``` – Encargado de ejecutar la lógica de publicación del caso.

##### 4.2.3.3. Application Layer  

### Command Handlers

**PublishCaseCommandHandler**

Maneja la lógica de publicación de un caso legal como respuesta a un comando.

- **Métodos:**
    - ```Handle(command: PublishCaseCommand)``` – Recupera el caso desde el repositorio, valida la publicación, actualiza el estado y dispara eventos de dominio.
- **Dependencias:**
    - ```ILegalCaseRepository```
    - ```CasePublishingService```

### Event Handlers

**CasePublishedEventHandler**

Maneja el evento que se genera al publicar un caso legal.

- **Métodos:**
    - ```Handle(event: CasePublishedEvent)``` – Notifica al servicio de emparejamiento sobre un nuevo caso publicado.
- **Dependencias:**
    - ```IMatchmakingService```

##### 4.2.3.4. Infrastructure Layer  

### Implementations

**LegalCaseRepositoryEF**

Implementación de ILegalCaseRepository usando Entity Framework.

- **Métodos:**
    - ```GetById(id: UUID): LegalCase``` – Recupera un caso desde la base de datos, incluyendo sus postulaciones.
    - ```Add(legalCase: LegalCase)``` – Persiste un nuevo caso.
    - ```Update(legalCase: LegalCase)``` – Actualiza los datos del caso en la base de datos.
- **Dependencias:**
    - ```AppDbContext```

**DomainEventDispatcher**

Encargado de propagar eventos de dominio al sistema de mensajería.

- **Métodos:**
    - ```Dispatch(event: IDomainEvent)``` – Publica el evento en el bus de mensajes.
- **Dependencias:**
    - ```IMessageBus```

##### 4.2.3.5. Bounded Context Software Architecture Component Level Diagrams  

<img src="/assets/images/chapter-IV/bc-cases/cases-component-diagram.png" alt="bc-cases-component-diagram"/>

Este diagrama de componentes representa la estructura interna del módulo de gestión de casos legales en LawConnect, organizado en capas. El flujo comienza con el Cases Controller que recibe peticiones HTTP y las deriva al Case Service, el cual orquesta la lógica principal utilizando los modelos del Domain Layer (entidades como LegalCase y CaseApplication). El servicio interactúa con múltiples repositorios (Case Repository, Application Repository, Client Repository y Lawyer Repository) para persistir datos en la base de datos, manteniendo una separación clara entre la lógica de negocio y el acceso a datos. Este diseño sigue principios DDD, con componentes especializados que permiten escalabilidad y facilitan la integración con otros contextos del sistema, todo ello representado visualmente mediante relaciones que muestran el flujo de datos y dependencias entre los distintos elementos arquitectónicos.

##### 4.2.3.6. Bounded Context Software Architecture Code Level Diagrams

###### 4.2.3.6.1. Bounded Context Domain Layer Class Diagrams  

<img src="/assets/images/chapter-IV/bc-cases/cases-class-diagram.png" alt="bc-cases-class-diagram"/>

Este diagrama modela el dominio específico de gestión de casos legales en LawConnect, estructurado bajo los principios de Domain-Driven Design. Representa las entidades centrales (LegalCase como raíz de agregado y CaseApplication para postulaciones), objetos valor (BudgetRange, DocumentRequirement) y servicios de dominio (CasePublishingService, CaseAssignmentService) que encapsulan la lógica para publicar casos, gestionar postulaciones y realizar asignaciones. El diseño muestra las relaciones entre estos componentes, las invariantes del negocio (como la restricción de una única postulación aceptada por caso) y las interfaces clave (repositorios) que permiten la integración con otros contextos del sistema, manteniendo un límite bien definido alrededor de este subdominio específico de la aplicación.

###### 4.2.3.6.2. Bounded Context Database Design Diagram

<img src="/assets/images/chapter-IV/bc-cases/cases-database-diagram.png" alt="bc-cases-database-diagram" width="500"/>

Este diagrama de base de datos del Bounded Context Cases define la estructura de persistencia para los casos legales y sus relaciones. La tabla principal ```LEGAL_CASES``` almacena la información básica de cada caso (título, descripción, presupuesto y estado), mientras que ```CASE_APPLICATIONS``` gestiona las postulaciones de los abogados, incluyendo propuestas económicas y estados de aceptación. La tabla ```CASE_DOCUMENTS_REQ``` registra los documentos requeridos para cada caso. Las relaciones has y requires reflejan la vinculación entre entidades, asegurando la integridad referencial y soportando consultas eficientes para el emparejamiento (matchmaking) y seguimiento de casos.

#### 4.2.4. Bounded Context: Matchmaking  
En esta parte el informe se describirá el proceso de diseño a nivel táctico del bounded context "Matchmaking", el cual permitirá a los clientes tener un abogado acorde al caso que presenta.

##### 4.2.4.1. Domain Layer  
Aquí se explicará el núcleo del negocio utilizado en "Matchmaking". También se mostrarán los modelos y reglas de negocio aplicadas al bounded context.

**Model**  
*Aggregates*  
`Match`: Este aggregate root, representado por una clase, es la relación entre un cliente y su abogado respecto a la recomendación producida en la entidad `Recommendation`.

*Entities*  
`Recommendation`: Esta clase representa una sugerencia basada en los criterios definidos en el value object `SearchCriteria`.

*Value Objects*  
`SearchCriteria`: Esta clase va procesar el criterio de búsqueda dependiendo de la puntuación, especialidad y ubicación del abogado respecto al cliente.

`MatchStatus`: Esta clase enum representa los posibles estados de un Match; esto define si la sugerencia fue rechazada (REJECTED), aceptada (ACCEPTED) o si sigue pendiente (SUGGESTED).

*Commands*  
`CreateMatchCommand`: Este comando es para crear un match nuevo.

`AcceptMatchCommand`: Este es un comando para designar que el match ha sido aceptado por el cliente.

`RejectMatchCommand`: Este comando es para designar que el match ha sido rechazado por el cliente.

`CreateRecommendationCommand`: Este es un comando para crear una recomendación a partir de la información del cliente y abogado.

*Queries*  
`GetMatchByIdQuery`: Esta consulta recupera un match específico por su Id (único).

`GetMatchByClientIdAndLawyerIdQuery`: Esta consulta devuelve el match respecto al Id del cliente y del abogado.

`GetAllMatchesByClientIdQuery`: Esta consulta lee todos los matches por el Id del cliente.

`GetAllMatchesByLawyerIdQuery`: Esta consulta lee todos los matches por el Id del abogado.

`GetAllRejectedMatchesByClientIdQuery`: Esta consulta lee todos los matches rechazados por el Id del cliente.

`GetAllAcceptedMatchesByClientIdQuery`: Esta consulta lee todos los matches aceptados por el Id del cliente.

`GetAllSuggestedMatchesByClientIdQuery`: Esta consulta lee todos los matches por el Id del cliente.

`GetAllRecommendedLawyersQuery`: Esta consulta recupera todos los abogados recomendados acorde al criterio de búsqueda.

*Events*  
`SuggestedLawyerEvent`: Este evento representa el evento de la sugerencia de un abogado para el cliente respecto al caso.

**Services**  
*Command Service*  
`MatchmakingCommandService`: Interfaz que define las operaciones relacionadas al bounded context.

*Query Service*  
`MatchmakingQueryService`: Interfaz que define los queries del bounded context.

##### 4.2.4.2. Interface Layer
Aquí se presentarán las clases pertenecientes al API que interactúan directamente con el exterior, los transformadores y controladores.

**RESTful API**  
*Controller*  
`MatchmakingController`: Este es el controlador que expone los endpoints RESTful, permite a los usuarios interactuar con el bounded context. Aquí se tienen en cuenta las consultas y comandos realizados por los usuarios.

*Resources*  
`MatchResource`: Recurso que representa el match generado al cliente.

`CreateMatchResource`: Este recurso permite que se genere el match acorde a los datos ingresados por el cliente y caso.

`RecommendationResource`: Este recurso permite presentar las recomendaciones hechas para el cliente.

`CreateRecommendationResource`: Este recurso permite crear la recomendación a partir de los datos ingresados por el cliente y caso.

*Assemblers*  
`MatchResourceFromEntityAssembler`: Transforma la entidad de Match a MatchResource.

`CreateMatchCommandFromResourceAssembler` Transforma el recurso de creación de Match en el comando de creación.

`RecommendationResourceFromEntityAssembler`: Transforma la entidad de Recommendation a RecommendationResource.  

`CreateRecommendationCommandFromResourceAssembler`: Transforma el recurso de creación de Recommendation en el comando de creación.

**ACL**  
`MatchmakingContextFacade`: Se utiliza esta clase para exponer la información de Matchmaking para los otros bounded contexts que lo necesiten.

Se utiliza ACL para proteger el bounded context; así, no se acoplará directamente a los otros bounded contexts que lo utilice.

##### 4.2.4.3. Application Layer
En esta capa se presentarán los flujos de negocios en el bounded context.

**Internal**  
*Command Services*  
`MatchmakingCommandServiceImpl`: Esta es la implementación del servicio de comandos del bounded context.

*Query Services*  
`MatchmakingQueryServiceImpl`: Esta es la implementación del servicio de consultas del bounded context.

*Outbound Services*  
`ExternalCaseService`: Se utiliza esta clase para obtener la información de los casos en el bounded context Cases.

`ExternalProfileService`: Esta clase se encarga de obtener la información relevante y necesaria del bounded context Profiles para los filtros de Matchmaking.

*Event Handlers*  
`SuggestedLawyerEventHandler`: Esta clase maneja el evento de la sugerencia de abogado al cliente.
##### 4.2.4.4. Infrastructure Layer
En esta sección se presentará el repositorio para el bounded context.

**Repository**  
`MatchRepository`: Esta interfaz es el repositorio para la entidad Match, en la cual se definen los métodos necesarios para realizar consultas y operaciones.

##### 4.2.4.5. Bounded Context Software Architecture Component Level Diagrams

En este diagrama se muestra la relación entre las clases que pertenecen al bounded context Matchmaking.  

![Container Diagram for Matchmaking](assets/images/chapter-IV/bc-matchmaking/container-diagram-bc-matchmaking.png)  


![Component Diagram for Matchmaking](assets/images/chapter-IV/bc-matchmaking/component-diagram-bc-matchmaking.png)  


##### 4.2.4.6. Bounded Context Software Architecture Code Level Diagrams

En esta sección del informe, se presentarán los diagramas a nivel de programación para tener una guía del funcionamiento de la aplicación y que se detalle las características del bounded context.


###### 4.2.4.6.1. Bounded Context Domain Layer Class Diagrams

En este diagrama se muestra la relación entre las clases que pertenecen al bounded context Matchmaking.


![Class Diagram for Matchmaking](assets/images/chapter-IV/bc-matchmaking/LawConnect-class-diagram-bc-matchmaking.png)  


Enlace del diagrama en Lucidchart: https://lucid.app/lucidchart/f562fb42-f94d-4840-be83-ef1c400180f5/edit?viewport_loc=-16%2C283%2C1727%2C1241%2CHWEp-vi-RSFO&invitationId=inv_f78a52cc-3e46-4d38-ac9a-28478a2a2a48

###### 4.2.4.6.2. Bounded Context Database Design Diagram

En esta sección se presenta el diseño de la base de datos para el bounded context Matchmaking

![Database Diagram for Matchmaking](assets/images/chapter-IV/bc-matchmaking/LawConnect-database-diagram-bc-matchmaking.png)  

Enlace del diagrama en Vertabelo: https://my.vertabelo.com/doc/OI6qkFKkRmRYm4KuK5dY1njVWEKdF68Z  

#### 4.2.5. Bounded Context: Tracking

##### 4.2.5.1. Domain Layer  

La capa de Dominio es la capa que contiene el núcleo del modelo de negocio y la lógica de dominio.

**Aggregate Root:** 
- Analytic: Entidad raíz que representa un seguimiento de caso legal. Contiene estado, timestamps, e IDs relevantes. Tiene lógica interna para construir y actualizarse con los comandos correspondientes.

**Interfaces:**
- AnalyticCommandService: Define las operaciones del dominio para aplicar comandos: handle(CreateAnalyticCommand) y handle(UpdateAnalyticCommand)

- AnalyticQueryService: Define las operaciones del dominio para ejecutar consultas: handle(GetAnalyticByCaseIdQuery) y handle(GetAnalyticsByUserIdQuery)

**Comandos:**
- CreateAnalyticCommand: Objeto que encapsula los datos necesarios para crear una nueva instancia de Analytic.

- UpdateAnalyticCommand: Objeto que encapsula los datos necesarios para actualizar una instancia existente de Analytic.

**Consultas:**
- GetAnalyticByCaseIdQuery: Objeto para solicitar una analítica por ID de caso.

- GetAnalyticsByUserIdQuery: Objeto para solicitar todas las analíticas asociadas a un ID de usuario.

##### 4.2.5.2. Interface Layer  

La capa de Interfaz es la capa responsable de exponer el API al exterior y transformar los datos entre el modelo de dominio y los recursos HTTP.

**Controlador:**
- AnalyticController: Controlador que representa los metodos que se van a exponer  a la web, esta clase se encarga de interactuar con el usuario mediante  HTTP. Esta clase tiene dependencias con los transformadores y los contratos definidos para cada servicio, esto porque los transformadores tienen la responsabilidad de serializar las clases que representan respuestas del servicio en commandos o en la entidad principal.

**Recursos:**
- CreateAnalyticResource: Objeto que representa los datos enviados por el cliente para crear un seguimiento.

- UpdateAnalyticResource: Objeto que representa los datos enviados por el cliente para actualizar un seguimiento.

- AnalyticResource: Representación del seguimiento de caso devuelta al cliente tras una operación o consulta.

**Assemblers (Transformadores):**
- CreateAnalyticCommandFromResourceAssembler: Convierte CreateAnalyticResource en CreateAnalyticCommand.

- UpdateAnalyticCommandFromResourceAssembler: Convierte UpdateAnalyticResource en UpdateAnalyticCommand.

- AnalyticResourceFromEntityAssembler: Transforma un objeto del dominio Analytic en un AnalyticResource para ser enviado al cliente.

##### 4.2.5.3. Application Layer  

La capa de Aplicación es la capa que contiene la lógica de aplicación, orquesta las operaciones entre capas externas y el dominio.

**Interfaces:**
- ExternalCaseService: Define el método updateCaseStatus para sincronizar el estado del caso con sistemas externos.

- ExternalUserService: Define el método isUserExist para verificar si un usuario existe externamente.

**Implementaciones:**
- AnalyticCommandServiceImpl: Implementa la lógica para crear y actualizar seguimientos de casos (Analytic) usando comandos.

- AnalyticQueryServiceImpl: Implementa las consultas sobre los seguimientos.

- ExternalCaseServiceImpl: Implementa el cambio de estado de un caso en el sistema externo.

- ExternalUserServiceImpl: Implementa la validación de usuarios consultando una fuente externa.

##### 4.2.5.4. Infrastructure Layer  

La capa de Infraestructura es la capa encargada de la persistencia y conexión con sistemas externos.

**Repositorio:**
- AnalyticRepository: Interfaz que define operaciones de acceso a datos sobre la entidad Analytic. Su implementación concreta se encargará de interactuar con la base de datos.

##### 4.2.5.5. Bounded Context Software Architecture Component Level Diagrams  

A continuación se muestra el diagrama de componentes realizado para el Bounded Context "Tracking".

<img src="/assets/images/bc-tracking/Component%20Diagram%20Tracking%20BC.jpg" width="500"/>  


<img src="/assets/images/bc-tracking/Tracking%20BC%20Component%20Diagram%202.jpg" width="500"/>

##### 4.2.5.6. Bounded Context Software Architecture Code Level Diagrams

###### 4.2.5.6.1. Bounded Context Domain Layer Class Diagrams  

A continuación se muestra el diagrama de clases realizado para el Bounded Context "Tracking".

<img src="/assets/images/bc-tracking/Tracking%20BC%20Diagram.png" width="500"/>

Link LucidChart: https://lucid.app/lucidchart/2f24abad-a0f7-43a4-88aa-75a98155725e/edit?viewport_loc=1513%2C-2244%2C5287%2C2801%2C0_0&invitationId=inv_fec486bd-cd05-4ba0-a373-c0d6f0b3cc42 

###### 4.2.5.6.2. Bounded Context Database Design Diagram

A continuación se muestra el diagrama de Base de Datos realizado para el Bounded Context "Tracking".

<img src="/assets/images/bc-tracking/TrackingBD.png" width="500"></img><br>

Link Vertabelo: https://my.vertabelo.com/doc/ljhlltORV7P42DB1eXIYnSo56Gft5W2d 

## Capítulo V: Solution UI/UX Design 

### 5.1. Product Design

#### 5.1.1. Style Guidelines 

##### 5.1.1.1. General Style Guidelines

#### 5.1.2. Information Architecture  

##### 5.1.2.1. Organization Systems 

##### 5.1.2.2. Labelling Systems

##### 5.1.2.3. SEO Tags and Meta Tags 

##### 5.1.2.4. Searching Systems  

##### 5.1.2.5. Navigation Systems

#### 5.1.3. Landing Page UI Design  

##### 5.1.3.1. Landing Page Wireframe 

##### 5.1.3.2. Landing Page Mock-up

#### 5.1.4. Mobile Applications UX/UI Design 

##### 5.1.4.1. Mobile Applications Wireframes

##### 5.1.4.2. Mobile Applications Wireflow Diagrams  

##### 5.1.4.3. Mobile Applications Mock-ups 

##### 5.1.4.4. Mobile Applications User Flow Diagrams 

##### 5.1.4.5. Mobile Applications Prototyping

## Capítulo VI: Product Implementation, Validation & Deployment

### 6.1. Software Configuration Management

#### 6.1.1. Software Development Environment Configuration

#### 6.1.2. Source Code Management

#### 6.1.3. Source Code Style Guide & Conventions

#### 6.1.4. Software Deployment Configuration

### 6.2. Landing Page & Mobile Application Implementation

#### 6.2.X. Sprint n

##### 6.2.X.1. Sprint Planning n

##### 6.2.X.2. Sprint Backlog n

##### 6.2.X.3. Development Evidence for Sprint Review

##### 6.2.X.4. Testing Suite Evidence for Sprint Review

##### 6.2.X.5. Execution Evidence for Sprint Review

##### 6.2.X.6. Services Documentation Evidence for Sprint Review

##### 6.2.X.7. Software Deployment Evidence for Sprint Review

##### 6.2.X.8. Team Collaboration Insights during Sprint

### 6.3. Validation Interviews

#### 6.3.1. Diseño de Entrevistas

#### 6.3.2. Registro de Entrevistas

#### 6.3.3. Evaluaciones según heurísticas

### 6.4. Video About-the-Product

## Conclusiones

## Conclusiones y recomendaciones 

## Video About-the-Team

## Bibliografía

<<<<<<< HEAD
## Anexos
=======
## Anexos 
>>>>>>> feature/bc-tracking
